This group of parameters provides an alternative way to filter classes and members
that appear in the generated documentation.
<p>
As you know, one of the new language features introduced in Java&nbsp;5 is <i>"annotations"</i>.
Annotations are essentially similar to tags. However, unlike tags,
they are specified not within Java comments, but directly in Java code.
That is, annotations are processed by the Java compiler itself and can be retained
in the compiled binary classes (which is impossible with tags).
<p>
So, you can use annotations the same as tags to mark some of your classes and members
to filter them out or retain in the generated documentation.
<p>
But, why would you need to use annotations? Why are tags not enough?
<p>
Let's suppose, you have a library of some core Java classes for internal use.
That library is quite a separate thing.
So, you may use it in different projects (or different people are using it).
Therefore, you maintain that library in a pre-compiled binary form as a jar-file.
<p>
Now, you develop a project, in which you use that internal library.
You want to publish certain classes of that project as an open API to your system.
But some of those classes are inherited from the classes contained in your internal library
(or implement interfaces from it).
An ordinary Java API documentation generated by Javadoc would mention those internal classes
as superclasses (implemented interfaces) of your API.
But you want them to be invisible in the published documentation. They are internal after all!
So, how can you do that?
<p>
Marking your internal classes with tags will not work,
because your tags will not get into the compiled jar-file. 
<p>
Here is where annotations can help! Let's see how you can do it.
<p>
First, you need to define your annotation type like the following (all names are for example):
<dl><dd>
<pre><code>
package myprojects.core.util;

public @interface Internal {
}
</code></pre>
</dd></dl>
Those lines should be saved as <i><code>Internal.java</code></i> file located in
<i><code>'myprojects/core/util'</code></i> package.
<p>
Note that as with any Java class, the defined annotation type has a <b>fully qualified name</b>,
which will be the string: <i><code>"myprojects.core.util.Internal"</code></i>.
Only the fully qualified name can be used to find annotations of a given type.
<p>
Now, you can use this annotation type to mark your internal classes.
Here is how:

<dl><dd>
<pre><code>
package myprojects.core.classes;
...
<font color="red">import myprojects.core.util.Internal;

@Internal</font>
public class MyIterator {
...
}
</code></pre>
</dd></dl>

After that, you can exclude all classes marked with that annotation from the generated documentation
by specifying the annotation type qualified name <i><code>'myprojects.core.util.Internal'</code></i>
in the <i>"Filter Classes & Members | By Annotations | Exclude | Classes"</i> parameter.
<p>
This will equally work both with the classes defined in the Java sources and the binary classes
found on the  Javadoc classpath!